# Mars Rover Kata

## Installation

- Run `npm install` followed by `npm test` to run the tests

- Run `npm start` to use the UI.

## Key Features

This implementation includes a UI that can be accessed in the console. The UI is initiated by _index.ts_, which sets up a data structure, `d: MarsData`. In the future, this could be transfered into a database. The initiatlisation then calls the function `goToMars()` to begin our voyage.

The UI (via _ui/plateau.ts_) will initially ask for two inputs – the width and height of a rectangular plateau – which will be generated by the `generateRectMap()` function in _setup.ts_. It seemed appropriate to use an array of strings to portray the map, with a middle dot `·` depicting a navigable part of the terrain – each string represents a row of the plateau.

The UI (via _ui/landing.ts_) will then ask for landing coordinates (and a direction to be facing) for the rover, and will check that it lands successfully on the plateau by calling `roverLandsOnPlateau()` (also in _setup.ts_). The UI can currently only handle one rover.

An ASCII map of the plateau is drawn in the console (`drawPlateau()`), and once the rover has landed it will show the rover's position and the direction it is facing with an arrow (`generateRoverMap()` in _map.ts_). This is accomplished by tracking the _position_ (_x,y_, and the _d_-irection it's facing) of the rover separately from the map (array of strings).

The UI then allows a user to drive the rover around the plateau, by inputing instructions: M to move forward one, and L and R to turn left or right by 90º respectively. The input can handle multiple instructions at once (e.g. "MMMRMMLM"), and will warn the user:

1. if an invalid instruction is given (i.e. a character other than M, L or R), or
2. if the rover is unable to complete an instruction (i.e. it will refuse to drive off the plateau)

Unfortunately, the code here is a little messy, and isn't very DRY – the UI `driveAround()` function calls a combination of `getNewPosition()`, `terrainIsNavigable()` (from _move.ts_) and `moveRover()` (from _maneuver.ts_). However, `moveRover()` also calls those other two functions, using the same logic. The messiness was created when I decided I wanted to give the user warnings when movement instructions were refused – which the `moveRover()` function had no clean way to communicate to the UI. Perhaps this could be refactored, so that the `moveRover()` function would throw Errors, which could be caught by the UI? I ran out of time to implement this.

Finally, the `landAndCommandRovers()` function in _command.ts_ is the function that implements the kata as requested, with the ability to handle multiple rovers given multiple instructions, and returns the coordinates and facing direction of each of the rovers.

## Approaches

My first realisation was to notice that I needed to create a map, and that the position of the rover needed to be in a separate data structure, and not simply determined by its position on the map. As such, I was thinking about data structure before I began coding.

The next step was to write tests and then code, which I did pretty much in the order of the Key Features section, except that the tests and source functions were written and tested before the UI was begun.

Once the UI was working, there were some errors with movement that pointed to the source functions not quite functioning as expected. This also revealed that my tests were insufficient, as there were a few cases when I moved a rover off the edge of a plateau. This caused me to re-check my source code functions, and make a few adjustments. A learning here is that my tests need to be more thorough from the start.

In terms of file structure, I have only separated the UI from the source code with separate folders. If this app were to develop further, additional folders would be appropriate. It may also be the case that a separate folder for tests would be desirable.

## Future Thoughts

The `terrainIsNavigable()` function is written in a way to be extensible. It not only checks that the given coordinates are within the bounds of the plateau, but it also checks the ASCII character of the target destination is navigable (i.e. a middle-dot `·`). This allows checks to be made for non-rectangular plateaus, or for where obstacles exist within a plateau. The tests include checking that a rover would not walk into a rock (marked with an x) in the `const rockyPlateau = ["···x", "·x·x"];`.

It would not be too much work to change the UI to accept a text file as its input map, which would allow one to create a plateau of any shape, that also contained obstacles. A caveat to this is that the map should be rectangular, i.e. that every row/string needs to be of the same length, as currently the length of the first row (`map[0].length`) is used to partly determine whether a rover can navigate to that location.

It may be that the rover would like to collect samples, and would like the mark those positions on the map. This could also be accomplished, such as by changing a `·` to a `s` on the map, and then adding `s` as a navigable terrain type. However, if samples are taken, then the sample's location would want to be logged alongside the sample's ID, so that these could be identified, and this would require additional data structures.

I tried adding the `cli-color` node module, to make the UI output prettier. However, Jest didn't play nicely with this, and the test in _map.test.ts_ began to fail. Adding colour would be desirable though!

In terms of additional features, I considered:

- Handling multiple rovers in the UI
- Handling custom plateaus, input via text files
- Generating other standard shapes of plateau (e.g. circle, hexagon)
- Be able to give names or IDs to rovers
- Allow for the collection and labelling of samples
- Monitor battery life of the rovers
- Monitor day and night cycle, and how the relates to the solar panels
